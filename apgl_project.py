# -*- coding: utf-8 -*-
"""APGL_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tio4AuwAmRqmg3R_soKr08m9aYhqHdl-

# Final Project - Advanced Python, Git & Linux

Team : Charles FRANCOIS ; Paul BECK ; Lucas-Aleksander FURJES

- /get_data: Fetches a list of articles from the site. Retrieving 5 articles might be sufficient.
- /articles: Displays information about the articles, including the article number, title, publication date, etc., but not the content itself.
- /article/<number>: Accesses the content of a specified article.
- /ml or /ml/<number>: Executes a machine learning script. Depending on the desired goal, it applies to either all articles or a single one. For example, sentiment analysis.
"""

#pip install textblob

# packages
from flask import Flask, jsonify, request
from textblob import TextBlob
import xml.etree.ElementTree as ET
import requests
import random

# we initialise the app flask
app = Flask(__name__)
# that's our main url from arXiv API for our requests
base_url = 'http://export.arxiv.org/api/query?'

# function to retrieve articles from arXiv
def fetch_articles():
  start_index = random.randint(0, 1000) # random index
  search_query = f'search_query=all:AI&start={start_index}&max_results=5'
  query_url = f"{base_url}{search_query}"
  # we send the HTTP GET request to the API
  response = requests.get(query_url)
  articles = []
  # check if the request was successful (status code 200)
  if response.status_code == 200:
    # parse the XML response
    root = ET.fromstring(response.content)
    ns = {'atom': 'http://www.w3.org/2005/Atom'} # we use the Atom namespace for easier searching in the XML doc

    for entry in root.findall('atom:entry', ns): #we recover each article from the XML feed
      # we retrieve basic informations about the articles
      title = entry.find('atom:title', ns).text.strip()
      summary = entry.find('atom:summary', ns).text.strip()
      published = entry.find('atom:published', ns).text
      authors = [author.find('atom:name', ns).text for author in entry.findall('atom:author', ns)]

      #we consider : get full content of the article = recover the pdf link
      pdf_link = None
      for link in entry.findall('atom:link', ns):
        if 'title' in link.attrib and link.attrib['title'] == 'pdf':
          pdf_link = link.attrib['href']
          break
      # add the article to the list of articles to be returned
      articles.append({'title': title,'summary': summary[:150] + "...",'published': published,'authors': ', '.join(authors),'pdf_link': pdf_link  })
  else:
    print(f"Oups we failed to fetch articles")

  return articles

# flask route for the endpoint /get_data
@app.route('/get_data', methods=['GET'])
def get_data():
  articles = fetch_articles()
  return jsonify(articles)

# flask route for the endpoint /articles
@app.route('/articles', methods=['GET'])
def articles():
  articles = fetch_articles()
  articles_info = [{'number': i, 'title': article['title']} for i, article in enumerate(articles, start=1)]
  return jsonify(articles_info)

# flask route for the endpoint /article/<int:number>
@app.route('/article/<int:number>', methods=['GET'])
def article(number):
  articles = fetch_articles()
  if 1 <= number <= len(articles):
    article = articles[number - 1]
    return jsonify(article)
  else:
    return jsonify({"error": "Article number out of range"}), 404

#function to perform sentiment analysis on content
def perform_sentiment_analysis(content):
  analysis = TextBlob(content)
  return analysis.sentiment

# flask route for the endpoints /ml and /ml/<int:number>
@app.route('/ml', methods=['GET'])
@app.route('/ml/<int:number>', methods=['GET'])
def ml(number=None):
  articles = fetch_articles()  # Fetch fresh articles
  if number:
    if 1 <= number <= len(articles):
      article = articles[number - 1]
      sentiment = perform_sentiment_analysis(article['summary'])
      return jsonify({"number": number, "sentiment": str(sentiment)})
    else:
      return jsonify({"error": "Article number out of range"}), 404
  else:
    sentiments = [{'number': i, 'sentiment': str(perform_sentiment_analysis(article['summary']))} for i, article in enumerate(articles, start=1)]
    return jsonify(sentiments)

# entry point of the flask app
if __name__ == '__main__':
  app.run(debug=True) # start the app

